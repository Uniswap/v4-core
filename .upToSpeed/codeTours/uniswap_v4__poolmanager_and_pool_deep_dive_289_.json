{"title":"Uniswap V4: PoolManager and Pool Deep Dive","id":"KVOgIll5UvCzni0P/xnJIfpmPlCOyK8bdUWmnk+QQjI=","steps":[{"type":"textOnly","description":"Welcome to the deep dive into **Uniswap v4**'s core components: `PoolManager.sol` and `Pool.sol`. These two contracts form the backbone of **Uniswap v4**'s architecture, introducing significant improvements and new features compared to previous versions. We'll explore their structure, key functions, and how they work together to manage liquidity pools and facilitate token swaps.","title":"","id":"2907"},{"type":"highlight","description":"Let's begin with `PoolManager.sol`. This contract is the **central hub** for managing all pools in **Uniswap v4**. It implements key functionalities such as initializing pools, modifying liquidity, executing swaps, and handling donations. Note the use of the **singleton design pattern**, where all pool states are managed within this single contract.","file":"src/PoolManager.sol","highlight":[{"start":77,"end":79}],"title":"","id":"2908"},{"type":"highlight","description":"Here we see the main state variable of **PoolManager**: `_pools`. This mapping stores all the **Pool.State** structs, indexed by `PoolId`. This is a crucial part of the singleton design, allowing efficient management of multiple pools within a single contract.","file":"src/PoolManager.sol","highlight":[{"start":93,"end":93}],"title":"","id":"2909"},{"type":"highlight","description":"The **initialize function** in `PoolManager.sol` is responsible for creating new liquidity pools. It performs several key operations: input validation, fee calculation, hook calls, pool initialization, and event emission. Let's examine each part in detail.","file":"src/PoolManager.sol","highlight":[{"start":115,"end":144}],"title":"","id":"2919"},{"type":"highlight","description":"The function begins with several input validation checks. These ensure that the **tick spacing** is within acceptable bounds and that the **currencies** are in the correct order.","file":"src/PoolManager.sol","highlight":[{"start":120,"end":128}],"title":"","id":"2920"},{"type":"highlight","description":"After validation, the function calculates the initial LP fee for the pool. This fee is derived from the `key.fee` parameter.","file":"src/PoolManager.sol","highlight":[{"start":130,"end":130}],"title":"","id":"2921"},{"type":"highlight","description":"The **initialize** function calls **hooks** before and after the actual `pool initialization`. These **hooks** allow for **custom logic** to be executed during the initialization process.","file":"src/PoolManager.sol","highlight":[{"start":132,"end":139}],"title":"","id":"2922"},{"type":"highlight","description":"The actual pool initialization occurs here. It creates a new `Pool.State` struct and initializes it with the provided parameters. The returned `tick` represents the initial price `tick` of the pool.","file":"src/PoolManager.sol","highlight":[{"start":134,"end":137}],"title":"","id":"2923"},{"type":"highlight","description":"Finally, the function emits an `Initialize` event. This event includes all the details of the newly created `pool`, allowing external systems to track `pool` creations.","file":"src/PoolManager.sol","highlight":[{"start":141,"end":143}],"title":"","id":"2924"},{"type":"highlight","description":"The **modifyLiquidity** function allows liquidity providers to add or remove liquidity from a pool. It interacts with the `Pool` library to update the pool state and calculates the resulting balance changes. Note the use of hooks before and after the operation, allowing for custom logic to be executed.","file":"src/PoolManager.sol","highlight":[{"start":147,"end":185}],"title":"","id":"2911"},{"type":"highlight","description":"Let's examine the `modifyLiquidity` function parameters and signature in detail. This function is crucial for managing liquidity in `Uniswap V4` pools.\n\n1. **PoolKey** memory `key`: This parameter represents the unique identifier for a specific liquidity pool. It likely contains information such as the token pair, fee tier, and other pool-specific data.\n\n2. `IPoolManager.ModifyLiquidityParams` memory `params`: This is a struct containing the details of the liquidity modification operation. It likely includes fields such as:\n   - `tickLower` and `tickUpper`: The price range for the liquidity position\n   - `liquidityDelta`: The amount of liquidity to add or remove\n   - `salt`: A unique value to prevent front-running\n\n3. `bytes` calldata `hookData`: This parameter allows for custom data to be passed to hooks, enabling extensibility and custom logic during liquidity operations.\n\nFunction modifiers:\n- **external**: The function can be called from outside the contract\n- **onlyWhenUnlocked**: Ensures the function can only be called when the contract is in an unlocked state\n- **noDelegateCall**: Prevents the function from being called via `delegatecall`, which is a security measure\n\nReturn values:\n- **BalanceDelta** `callerDelta`: Represents the net change in token balances for the caller\n- **BalanceDelta** `feesAccrued`: Represents the fees earned by the liquidity provider\n\nThese parameters and return values work together to provide a flexible and secure way to modify liquidity in `Uniswap V4` pools, while also allowing for extensibility through hooks.","file":"src/PoolManager.sol","highlight":[{"start":147,"end":151}],"title":"","id":"2947"},{"type":"highlight","description":"The function begins by retrieving the pool state and checking if it's initialized:","file":"src/PoolManager.sol","highlight":[{"start":152,"end":155}],"title":"","id":"2948"},{"type":"highlight","description":"Before modifying liquidity, a pre-operation hook is called. This allows for custom logic execution.","file":"src/PoolManager.sol","highlight":[{"start":157,"end":157}],"title":"","id":"2949"},{"type":"highlight","description":"The core liquidity modification is performed using the Pool library. This operation updates the pool state and calculates balance changes.","file":"src/PoolManager.sol","highlight":[{"start":159,"end":169}],"title":"","id":"2950"},{"type":"highlight","description":"After modifying liquidity, the function calculates the caller's balance delta.","file":"src/PoolManager.sol","highlight":[{"start":171,"end":172}],"title":"","id":"2951"},{"type":"highlight","description":"An event is emitted to log the liquidity modification.","file":"src/PoolManager.sol","highlight":[{"start":175,"end":176}],"title":"","id":"2952"},{"type":"highlight","description":"After modifying liquidity, a post-operation hook is called. This allows for additional custom logic.","file":"src/PoolManager.sol","highlight":[{"start":178,"end":179}],"title":"","id":"2953"},{"type":"highlight","description":"Finally, the function accounts for any balance changes resulting from the operation.","file":"src/PoolManager.sol","highlight":[{"start":181,"end":184}],"title":"","id":"2954"},{"type":"highlight","description":"The **swap function** is the core of token exchanges in `Uniswap V4`. It begins with several important checks and initializations:","file":"src/PoolManager.sol","highlight":[{"start":188,"end":197}],"title":"","id":"2925"},{"type":"highlight","description":"Before executing the **swap**, a pre-**swap** hook is called. This hook allows for customization of the **swap** process.","file":"src/PoolManager.sol","highlight":[{"start":199,"end":203}],"title":"","id":"2926"},{"type":"highlight","description":"The **swap** is executed by calling the internal `_swap` function. This function performs the actual token exchange and updates the pool state.","file":"src/PoolManager.sol","highlight":[{"start":205,"end":219}],"title":"","id":"2927"},{"type":"highlight","description":"After the **swap** is executed, a **post-swap hook** is called. This allows for additional actions or calculations based on the **swap** result.","file":"src/PoolManager.sol","highlight":[{"start":221,"end":222}],"title":"","id":"2928"},{"type":"highlight","description":"Finally, the function accounts for any balance changes resulting from the swap and hooks.","file":"src/PoolManager.sol","highlight":[{"start":224,"end":228}],"title":"","id":"2929"},{"type":"highlight","description":"Now let's look at `Pool.sol`. This library contains the core logic for managing individual liquidity pools. It's used extensively by `PoolManager.sol` to perform operations on pools.","file":"src/libraries/Pool.sol","highlight":[{"start":1,"end":20}],"title":"","id":"2913"},{"type":"highlight","description":"The **Pool.State** struct defines the state of a single liquidity pool. It includes the current price (`sqrtPriceX96`), liquidity, and mappings for ticks and positions. This struct is what's stored in the `PoolManager`'s `_pools` mapping for each pool.","file":"src/libraries/Pool.sol","highlight":[{"start":80,"end":88}],"title":"","id":"2914"},{"type":"highlight","description":"The `initialize function` in `Pool.sol` sets up the initial state of a pool. It's called by `PoolManager`'s `initialize function`. Note how it sets the initial price, tick, and fees.","file":"src/libraries/Pool.sol","highlight":[{"start":97,"end":107}],"title":"","id":"2915"},{"type":"highlight","description":"The **modifyLiquidity** function is a core component of `Uniswap v4`'s liquidity management. It handles both adding and removing liquidity from a pool. Let's break down its key components:","file":"src/libraries/Pool.sol","highlight":[{"start":146,"end":153}],"title":"","id":"2930"},{"type":"highlight","description":"The **function** starts by extracting key parameters and performing initial checks.","file":"src/libraries/Pool.sol","highlight":[{"start":150,"end":153}],"title":"","id":"2931"},{"type":"highlight","description":"If there's a **non-zero liquidity change**, the function updates the `ticks`.","file":"src/libraries/Pool.sol","highlight":[{"start":158,"end":162}],"title":"","id":"2932"},{"type":"highlight","description":"When adding **liquidity**, the function checks for **potential overflow**:\n\n\n","file":"src/libraries/Pool.sol","highlight":[{"start":164,"end":173}],"title":"","id":"2933"},{"type":"highlight","description":"The function **updates** the `tick bitmap` if necessary:\n\n\n","file":"src/libraries/Pool.sol","highlight":[{"start":175,"end":180}],"title":"","id":"2934"},{"type":"highlight","description":"Next, **the function** updates the position and calculates **earned fees**:","file":"src/libraries/Pool.sol","highlight":[{"start":183,"end":193}],"title":"","id":"2935"},{"type":"highlight","description":"When removing liquidity, the function clears unnecessary tick data.","file":"src/libraries/Pool.sol","highlight":[{"start":195,"end":203}],"title":"","id":"2936"},{"type":"highlight","description":"Finally, the function calculates the amounts of tokens to be added or removed.","file":"src/libraries/Pool.sol","highlight":[{"start":206,"end":237}],"title":"","id":"2937"},{"type":"highlight","description":"The function begins by checking if there's a non-zero change in liquidity. If so, it retrieves the current pool state and prepares for token amount calculations.","file":"src/libraries/Pool.sol","highlight":[{"start":206,"end":208}],"title":"","id":"2955"},{"type":"highlight","description":"If the current tick is below the lower tick of the position, only token0 (the less valuable token) needs to be provided. The amount is calculated using the `SqrtPriceMath` library.","file":"src/libraries/Pool.sol","highlight":[{"start":209,"end":217}],"title":"","id":"2956"},{"type":"highlight","description":"If the current tick is within the position's range, amounts for both tokens are calculated. The `SqrtPriceMath` library is used to determine the required amounts of `token0` and `token1`.","file":"src/libraries/Pool.sol","highlight":[{"start":218,"end":224}],"title":"","id":"2957"},{"type":"highlight","description":"When the **current tick** is within the **position's range**, the **pool's liquidity** is updated by adding the **liquidityDelta** to the current liquidity.","file":"src/libraries/Pool.sol","highlight":[{"start":226,"end":226}],"title":"","id":"2958"},{"type":"highlight","description":"If the current tick is above the upper tick of the position, only token1 (the more valuable token) needs to be provided. The amount is calculated using the `SqrtPriceMath` library.","file":"src/libraries/Pool.sol","highlight":[{"start":227,"end":236}],"title":"","id":"2959"},{"type":"textOnly","description":"The `swap` function in `Pool.sol` is the **core** of Uniswap v4's **trading logic**. It handles the entire swap process, from initialization to final state updates. Let's break down this complex function into manageable parts for a thorough audit.","title":"","id":"2938"},{"type":"highlight","description":"1. The **swap function** begins by initializing key variables:\n   - It retrieves the current pool state (`slot0Start`)\n   - Sets the swap direction (`zeroForOne`)\n   - Calculates the protocol fee\n   - Initializes tracking variables for the remaining amount to be swapped and the amount calculated\n   - Sets initial values for price, tick, and liquidity","file":"src/libraries/Pool.sol","highlight":[{"start":279,"end":298}],"title":"","id":"2939"},{"type":"highlight","description":"The function begins by retrieving the current pool state and determining the swap direction. The swap direction is crucial as it affects all subsequent calculations and state updates:\n\n1. `slot0Start = self.slot0`: This retrieves the current state of the pool, including the current price and tick.\n\n2. `zeroForOne = params.zeroForOne`: This boolean determines the direction of the swap:\n   - If `true`, we're swapping token0 for token1 (price is decreasing)\n   - If `false`, we're swapping token1 for token0 (price is increasing)\n\nThe swap direction impacts:\n- Which token is being sold and which is being bought\n- How price limits are checked (lines 322-338)\n- Which global fee growth variable is updated (line 341)\n- The direction of tick traversal in the main swap loop\n- How liquidity net values are interpreted when crossing ticks (lines 419-422)\n- Final fee growth and state updates (lines 442-445)\n\nAs an auditor, it's crucial to verify that all these directional logic branches are correctly implemented to prevent potential vulnerabilities or inconsistencies in the swap process.","file":"src/libraries/Pool.sol","highlight":[{"start":283,"end":284}],"title":"","id":"2961"},{"type":"highlight","description":"Next, the protocol fee is calculated based on the swap direction","file":"src/libraries/Pool.sol","highlight":[{"start":286,"end":287}],"title":"","id":"2962"},{"type":"highlight","description":"The function initializes variables to track the remaining amount to be swapped and the amount calculated","file":"src/libraries/Pool.sol","highlight":[{"start":289,"end":292}],"title":"","id":"2963"},{"type":"highlight","description":"Finally, the function sets initial values for the square root price, tick, and liquidity","file":"src/libraries/Pool.sol","highlight":[{"start":293,"end":298}],"title":"","id":"2964"},{"type":"highlight","description":"**2. Fee calculation and validation:**\n- The function determines the `LP fee`, either from a hook override or from storage\n- It calculates the total swap fee, combining `LP` and protocol fees\n- Checks if the swap fee exceeds the **maximum allowed**, which would make exact output swaps impossible\n- Handles the case where the specified amount is zero","file":"src/libraries/Pool.sol","highlight":[{"start":300,"end":320}],"title":"","id":"2940"},{"type":"highlight","description":"**3.Price limit checks are performed:**\n- For `zeroForOne` swaps, it ensures the **price limit** doesn't exceed the **current price** and is above the **minimum allowed price**.\n- For `oneForZero` swaps, it checks that the **price limit** is above the **current price** and below the **maximum allowed price**.\nThese checks prevent invalid swaps and ensure the swap operates within allowable price ranges.","file":"src/libraries/Pool.sol","highlight":[{"start":322,"end":338}],"title":"","id":"2941"},{"type":"highlight","description":"**4. Main swap loop initialization:**\n- A `StepComputations` struct is created to store intermediate calculations\n- The **global fee growth variable** is initialized based on the swap direction\n- The main swap loop begins, continuing until the entire amount is swapped or the price limit is reached","file":"src/libraries/Pool.sol","highlight":[{"start":340,"end":344}],"title":"","id":"2942"},{"type":"highlight","description":"5. For each iteration of the swap loop, a **swap step** is computed, let's see how","file":"src/libraries/Pool.sol","highlight":[{"start":345,"end":368}],"title":"","id":"2943"},{"type":"highlight","description":"1. At the start of each swap step, we initialize the starting price. This price is set to the current price of the pool, which is stored in result.sqrtPriceX96.","file":"src/libraries/Pool.sol","highlight":[{"start":345,"end":345}],"title":"","id":"2965"},{"type":"highlight","description":"2. Next, we find the nearest initialized tick in the direction of the swap. This is done using the tickBitmap, which efficiently stores information about which ticks are initialized. The function returns the next tick and whether it's initialized.","file":"src/libraries/Pool.sol","highlight":[{"start":347,"end":348}],"title":"","id":"2966"},{"type":"highlight","description":"3. After finding the next tick, we perform boundary checks. These checks ensure that we don't exceed the minimum or maximum allowed ticks, as the tickBitmap doesn't inherently respect these boundaries.","file":"src/libraries/Pool.sol","highlight":[{"start":350,"end":356}],"title":"","id":"2967"},{"type":"highlight","description":"4. Once we have the next valid tick, we calculate its corresponding price. This is done using the TickMath library, which converts between tick indices and sqrt prices.","file":"src/libraries/Pool.sol","highlight":[{"start":358,"end":359}],"title":"","id":"2968"},{"type":"highlight","description":"5. Finally, we compute the actual swap step. This calculation determines how much can be swapped within the current price range, considering the liquidity, remaining amount to be swapped, and the swap fee. The `SwapMath.computeSwapStep` function returns the new sqrt price, amount in, amount out, and fee amount for this step.","file":"src/libraries/Pool.sol","highlight":[{"start":361,"end":368}],"title":"","id":"2969"},{"type":"highlight","description":"6. After computing the swap step:\n- The remaining amount to be swapped and the amount calculated are updated\n- If a **protocol fee** is applied, it's calculated and deducted from the fee amount\n- The **global fee tracker** is updated based on the current liquidity\nThese updates ensure accurate tracking of the swap progress and fee accumulation.","file":"src/libraries/Pool.sol","highlight":[{"start":370,"end":404}],"title":"","id":"2944"},{"type":"highlight","description":"The function updates the remaining amount to be swapped and the amount calculated. This update depends on whether the swap is an **exact output** or **exact input** swap:","file":"src/libraries/Pool.sol","highlight":[{"start":370,"end":382}],"title":"","id":"2970"},{"type":"highlight","description":"For `exact output` swaps (where `params.amountSpecified > 0`), the function decreases the remaining amount by the output amount of this step, and decreases the calculated amount by the input amount plus the fee amount:","file":"src/libraries/Pool.sol","highlight":[{"start":371,"end":376}],"title":"","id":"2971"},{"type":"highlight","description":"For `exact input` swaps (where `params.amountSpecified <= 0`), the function increases the remaining amount by the input amount plus the fee amount, and increases the calculated amount by the output amount of this step:","file":"src/libraries/Pool.sol","highlight":[{"start":376,"end":382}],"title":"","id":"2972"},{"type":"highlight","description":"If a protocol fee is applied (`protocolFee` > 0), the function calculates the amount owed to the protocol:","file":"src/libraries/Pool.sol","highlight":[{"start":384,"end":395}],"title":"","id":"2973"},{"type":"highlight","description":"The protocol fee is calculated as a fraction of the total input amount (including the fee). This amount is then subtracted from the total fee and added to the protocol fee accumulator:","file":"src/libraries/Pool.sol","highlight":[{"start":386,"end":394}],"title":"","id":"2974"},{"type":"highlight","description":"Finally, if there's liquidity in the pool, the function updates the global fee tracker. This tracker accumulates fees relative to the current liquidity, ensuring fair distribution of fees to liquidity providers:","file":"src/libraries/Pool.sol","highlight":[{"start":397,"end":404}],"title":"","id":"2975"},{"type":"highlight","description":"**7. Tick and liquidity updates:**\n- If the swap reaches the next initialized `tick`, the `tick` is crossed\n- This involves updating the `tick`, potentially changing the active `liquidity`\n- If the price has changed but not reached the next `tick`, the current `tick` is recalculated\nThese updates ensure the pool state accurately reflects the post-swap conditions.\nlet's dive in","file":"src/libraries/Pool.sol","highlight":[{"start":406,"end":434}],"title":"","id":"2945"},{"type":"highlight","description":"The swap function now enters a critical phase: updating ticks and liquidity. This process ensures that the pool's state accurately reflects the post-swap conditions. Let's examine how Uniswap V4 handles these updates.","file":"src/libraries/Pool.sol","highlight":[{"start":406,"end":409}],"title":"","id":"2976"},{"type":"highlight","description":"First, the function checks if we've reached the next initialized tick. This occurs when the current square root price (`result.sqrtPriceX96`) equals the square root price of the next tick (`step.sqrtPriceNextX96`).","file":"src/libraries/Pool.sol","highlight":[{"start":410,"end":410}],"title":"","id":"2977"},{"type":"highlight","description":"If we've reached an initialized tick, the function performs a tick transition. This involves updating fee growth variables and calculating the net liquidity change. The **`Pool.crossTick`** function is called to handle the tick crossing, which may involve complex state updates.","file":"src/libraries/Pool.sol","highlight":[{"start":411,"end":417}],"title":"","id":"2978"},{"type":"highlight","description":"The `liquidityNet` value is adjusted based on the swap direction. For `zeroForOne` swaps (where we're moving to lower ticks), we negate `liquidityNet`. This is because when moving left on the price range, we're exiting liquidity positions rather than entering them.","file":"src/libraries/Pool.sol","highlight":[{"start":418,"end":422}],"title":"","id":"2979"},{"type":"highlight","description":"After adjusting `liquidityNet`, the function updates the pool's liquidity. It uses the `LiquidityMath.addDelta` function to safely add the net liquidity change to the current liquidity.","file":"src/libraries/Pool.sol","highlight":[{"start":424,"end":424}],"title":"","id":"2980"},{"type":"highlight","description":"When crossing to a new tick, the current tick (`result.tick`) is updated. For `zeroForOne` swaps, it's set to one less than the next tick, while for `oneForZero` swaps, it's set to the next tick. This ensures the tick always represents the lower bound of the current price range.","file":"src/libraries/Pool.sol","highlight":[{"start":427,"end":429}],"title":"","id":"2981"},{"type":"highlight","description":"If the price has changed (`result.sqrtPriceX96` != `step.sqrtPriceStartX96`) but we haven't reached the next tick, the function recalculates the current tick using `TickMath.getTickAtSqrtPrice`. This ensures the tick always accurately represents the current price, even for partial moves between ticks.","file":"src/libraries/Pool.sol","highlight":[{"start":430,"end":433}],"title":"","id":"2982"},{"type":"highlight","description":"After the swap loop completes, the pool's slot0 is updated with the new tick and square root price. slot0 is a crucial storage variable that holds the current state of the pool, including the current tick and price. This update ensures that the pool reflects the new state after the swap.","file":"src/libraries/Pool.sol","highlight":[{"start":436,"end":436}],"title":"","id":"2983"},{"type":"highlight","description":"Next, the pool's **liquidity** is updated, but only if it has changed during the **swap operation**. This check prevents unnecessary storage writes if the **liquidity** remained constant throughout the **swap operation**.","file":"src/libraries/Pool.sol","highlight":[{"start":438,"end":439}],"title":"","id":"2984"},{"type":"highlight","description":"The **global fee growth variables** are then updated. The update depends on the **swap direction** (`zeroForOne`). These variables track the **accumulated fees** per unit of liquidity and are crucial for calculating **LP rewards**.","file":"src/libraries/Pool.sol","highlight":[{"start":441,"end":446}],"title":"","id":"2985"},{"type":"highlight","description":"Finally, the swap delta is calculated. This represents the net amounts of tokens swapped. The calculation depends on whether the swap was `zeroForOne` and whether the amount specified was positive or negative (exact input vs. exact output swap).","file":"src/libraries/Pool.sol","highlight":[{"start":448,"end":459}],"title":"","id":"2986"},{"type":"textOnly","description":"As we conclude our deep dive into `PoolManager.sol` and `Pool.sol`, let's consider key auditing points:\n\n1. **Singleton Pattern**: Assess the implications of `PoolManager`'s singleton design on security and gas efficiency.\n\n2. **Hook System**: Thoroughly audit the hook mechanism, as it's a potential attack vector if not properly secured.\n\n3. **Liquidity Management**: Scrutinize `modifyLiquidity` and `swap` functions for edge cases and potential manipulations.\n\n4. **Price Calculations**: Verify the accuracy of price calculations, especially in extreme market conditions.\n\n5. **Fee Handling**: Ensure correct fee calculations and distributions, including protocol fees.\n\n6. **Reentrancy Protection**: Check for proper reentrancy guards, particularly in external calls.\n\n7. **Tick Management**: Audit the tick system for potential overflow/underflow issues.\n\n8. **State Updates**: Verify that all state updates are atomic and consistent across functions.\n\nWhen auditing, pay special attention to the interaction between `PoolManager` and `Pool`, as vulnerabilities often arise at these interfaces. This system's complexity demands a meticulous, multi-faceted audit approach.","title":"","id":"2918"}]}